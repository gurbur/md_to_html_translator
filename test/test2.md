아녕. 오늘도 접니다.

# Tokenizer
토크나이저!

주어진 문자열을 '토큰'이라는 단위로 쪼개주는 역할을 하는 프로그램입니다.

마크다운으로 작성된 블로그의 글을 html로 번역하기에 앞서서, 일정한 단위로 쪼개주는 일을 하게 될 겁니다.

그러면 뭘 해야하나...

# 번역 할 문법?
먼저 어떤 문자열을 번역해야 하는지 먼저 생각해 봐야겠죠.

아래에서 str은 아무런 역할을 갖지 않는 문자들의 조합으로 이루어진 문자열을 의미합니다.
번역할 문자열의 타입과 구조를 줄글로 쭉 작성해보면...

Heading1 (# str_with_enter)
Heading2 (## str_with_enter)
Heading3 (### str_with_enter)
Code Block (\`\`\`lang_name\\n multi-lined_str\`\`\`\\n)
Line (---\n or \*\*\*\\n)
Ordered List (n. str_with_enter)
Unordered List (- str_with_enter)

이 정도 될 것 같네요.
이 중에 중요한 건, 각 List는 여러 줄이 연달아 있을 경우, 한 개의 덩어리로 묶여야 한다는 점이에요.

잊으면 안되는게, Paragraph 속 문자열에 효과를 줄 수도 있어야 해요.
또한, 옵시디언에서 사용하는 Paragraph 속 참조 문법도 있었죠,
이런 것들을 묶어서 **인라인 요소**라고 하도록 합시다.

Normal String (str, 특별한 역할이 없는 문자열들을 묶어두기 위해서)
Italic (\*str\*)
Bold (\*\*str\*\*)
Italic and Bold (\*\*\*str\*\*\*)
Inline Code (\`str\`)

Link (\[표면 상에 보일 문자열](주소))
Image Link (!\[\[이미지 파일 이름]]\n)

이런 모든 것을 묶어주는, Paragraph를 정의하면,

Paragraph (Normal String, Italic, Bold, Italic and Bold, Inline Code, Link, Image Link들의 묶음, \n\n 로 구분)

그리고, 모든 문자열에 역 슬래쉬(\\)가 있다면, 바로 뒤에 따라오는 문자는 특정 역할을 하지 못하도록 해야 하고, 또, html에서는 문서 내에서 구조적인 역할을 하는 특정 문자들을 변환해야 해요(ex. &, \<, \> -> &amp;, &lt;, &gt;)

헥.. 생각보다 고려할 사항이 많네요.

그럼 이걸 어떻게 수행할건가??

## Finite State Machine
먼저 제가 학교에서 배운 방법입니다.
**유한 상태 기계(Finite State Machine)** 를 활용하는 방법입니다.

...아니! 코딩하는데 무슨 기계냐!

여기서 말하는 기계는, 물리적으로 동작하는 실제 기계가 아니라 이론적 설계를 위해 구성하는 가상의 기계를 의미해요.

컴퓨터 과학에서는 밥 먹듯이 등장하는 개념이니, 알아두면 좋습니다.

![[7-1.png]]

상태 기계는 여러가지 노드들과 그 노드들 간의 연결인 간선으로 구성되는데요,

각 노드들을 하나의 "**상태(State)**" 라고 간주합니다.

시작 상태에서 출발해서, 특정 상황마다 사전에 정의된 선을 따라 움직이는데요, 이렇게 상태 사이를 움직이는 것을 "**전이(transition)** 한다" 라고 합니다.

이렇게 시작상태에서 전이를 하면서 종료 상태에 도달하면, 동작을 멈추게 됩니다.

이 도구는 개발의 여러 부분에서 쓰이고, 실제로 저도 게임을 개발하면서 몇 번 썼었습니다.

컴파일러에서 쓰는 FSM의 경우에는, 전이하는 조건으로 들어온 문자가 조건에 맞는 지를 확인합니다.

하지만, 마크다운은 나름 복잡한 구조를 띄고 있어서, 단순히 FSM만으로 구성하면 상태가 너무 많이 생길 수도 있어요.

그래서 찾아본 결과, 어느 정도 직접 문자 패턴을 검사해서 토큰을 만드는 Manual Pattern Matching을 섞어서 사용하기도 한다고 합니다.

저도 이렇게 FSM과 Manual Pattern Matching을 섞어서 진행하기로 했습니다.

구조는 먼저 Block단위에 속하는 Heading, Code Block, Line. List, Paragraph를 분류하고, 이중 뒤에 텍스트가 딸려오는 Heading, Order List, Unordered List, Paragraph에 대해서 Inline단위의 토크나이징을 진행하면 될 것 같네요!

## Block 단위 FSM
여기서 처리해야 할 건 Heading(1~3), Code Block, Line, Ordered List, Unordered List, Paragraph입니다.

참고로 Heading엔 6번째 까지도 지원을 하는 경우도 있습니다만... 저는 이렇게까지는 잘 쓰지 않으니까 3번째 까지만 사용하는 것으로 하죠!

각 라인의 첫 문자를 보고, 해당 문자가 \#이면 Heading 등, 이런식으로 처리하도록 하겠습니다.

이를 그래프화 해서 그리면...
![[7-2.png]]
(주의, 위의 그래프에는 편의를 위해 임의로 작성한 내용들이 존재합니다. 학문적으로는 엄밀히 말하면 틀린 내용이 포함되어 있을 확률이 높아요)

대충 이런 식으로 나올 겁니다. 각 전환은 문자/문자열이나 특수한 문자를 읽는 것을 나타내고, 종료 상태에 도달하면 해당 라인이 그 종료 상태의 토큰임을 나타내는거죠.

그리고 Headings, Lists, Paragraph 들의 경우, 해당 태그 내에서 문자열을 추가로 갖고 있죠??

이 문자열 내에서는, 위에서 정의했던 inline 요소들을 추가로 처리해줘야 해요.

## Inline 단위 FSM
여기서 처리할 건 Italic, Bold, Italic and Bold, Inline Code, Link, Image Link, 그리고 Normal String과 이 있습니다.

요 녀석은, 위의 블록 단위 처리에서 text에 해당하는 데이터가 있을 때 해당 내용을 받아오는 방식으로 작동할 겁니다.

그리고 위에서는 종료 상태에 들어서면, 해당 라인의 처리를 끝마치고 다음 라인으로 들어가는 것과 달리, 여기에선 한 상태에 들어서면 그 상태를 벗어날 때까지 나오는 모든 문자를 동일한 상태로 받아들여야 하고, 해당 상태의 종료를 의미하는 특정한 문자를 만나면 일반 상태로 돌아가서 다음 문자를 계속해서 처리 해줘야 합니다.

그러면 그래프를 그려보죠!
![[7-3.png]]
(주의, 이 그래프도 학술적으로는 정확한 표현이 아닐 가능성이 높습니다.)

역시 종료 상태가 하나 뿐이라서 복잡하네요...

그래도 이제 이걸 기반으로 코드를 작성하면 됩니다!

그건 다음에 작성해서 가져오도록 하죠.

그럼 안녕
***
2025.02.19 내용 추가
안녕, 정말 오랜만입니다

여행도 다니고, 새 학기에 사용할 가능성이 높은 것들을 이것저것 새롭게 공부하면서 보냈더니, 어느새 시간이 벌써 이렇게 되었네요.

아무튼 이렇게 다시 돌아온 이유는, **드디어 Tokenizer 개발을 완료했습니다!**

모든 내용은 제 [github](https://github.com/gurbur/md_to_html_translator) 레포에 올려 놨어요.

실행에 인자로 들어온 마크다운 파일을 받아서, 각 라인을 스캔하는 **Block Processing** 과정을 거친 후, 해당 라인의 타입이 인라인 요소를 포함할 수 있다면, 이를 각 문자마다 처리하는 **Inline Processing** 과정을 진행하는 방식으로 작동합니다.

말만 거창하지, 실제 코드를 보면 별거 없어요.
그냥 마크다운 파일 받아다가 반복문으로 상태 파악하고, 각 상태 별로 문자열 분석 하는게 다입니다.

결과 내용을 아직 외부로 보내는 부분은 작성되지 않았습니다만, 그래도 테스트 해본 결과, 간단히 작동은 합니다.

다음은 parser입니다. 앞으로도 잘 부탁해용
